<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polygon Comparison Playground (PoLiS)</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root{
      --bg:#f8fafc;         /* page background */
      --text:#0f172a;       /* primary text */
      --muted:#475569;      /* muted text */
      --border:#e5e7eb;     /* borders */
      --card:#ffffff;       /* cards */
      --shadow:0 6px 20px rgba(15,23,42,0.06);
      --blue:#3b82f6;       /* polygon A fill */
      --blue-stroke:#2563eb;
      --violet:#a855f7;     /* polygon B fill */
      --violet-stroke:#7c3aed;
      --grid:#94a3b31a;     /* subtle grid */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text)
    }
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}

    header{display:flex;flex-direction:column;gap:10px;margin-bottom:16px}
    h1{font-size:24px;letter-spacing:.2px;margin:0}
    .desc{color:var(--muted);line-height:1.45}

    .grid{display:grid;grid-template-columns:1fr 300px;gap:16px}
    @media (max-width: 1024px){.grid{grid-template-columns:1fr}}

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow:var(--shadow);
      overflow:hidden
    }
    .head{padding:12px 14px;border-bottom:1px solid var(--border)}
    .head h2{margin:0;font-size:16px}
    .body{padding:14px}

    .stage-wrap{display:flex;justify-content:center}
    svg.stage{
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      touch-action:none
    }

    .metrics{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .metric{
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      padding:10px
    }
    .metric small{
      display:block;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.04em;
      font-size:11px
    }
    .metric .val{font-weight:700;font-size:18px}
    .metric.accent{background:#eef2ff;border-color:#c7d2fe}
    .metric.accent .val{color:#4f46e5}

    .ctrl{display:flex;align-items:center;gap:8px;margin-top:8px}
    .switch{
      position:relative;
      width:44px;
      height:24px;
      border-radius:999px;
      background:#e2e8f0;
      border:1px solid var(--border);
      cursor:pointer
    }
    .knob{
      position:absolute;
      top:1px;
      left:1px;
      width:20px;
      height:20px;
      border-radius:50%;
      background:#fff;
      box-shadow:0 1px 3px rgba(0,0,0,.2);
      transition:transform .18s ease
    }
    .switch.on{background:#dbeafe;border-color:#bfdbfe}
    .switch.on .knob{transform:translateX(20px)}

    .hint{color:var(--muted);font-size:13px;margin-top:10px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Interactive polygon comparison</h1>
      <div class="desc">
        This interactive visualization compares two complementary metrics for polygon similarity:
        <br><br>
        
        <strong>PoLiS (Polygon-to-Line-Segment) distance</strong> measures the average distance between vertices of one polygon and the boundary of another polygon.
        The metric is computed as:
        $$\text{PoLiS}(A,B) = \frac{1}{2} \left( \frac{1}{|A|}\sum_{a_j \in A} \text{dist}(a_j, \partial B) + \frac{1}{|B|}\sum_{b_k \in B} \text{dist}(b_k, \partial A) \right)$$
        where \(\text{dist}(a_j, \partial B)\) is the shortest distance from vertex \(a_j\) to any edge of polygon \(B\).
        Key properties of PoLiS:
        <ul style="margin:8px 0;padding-left:20px;color:var(--muted)">
          <li>Compares polygons, not only point sets, with different numbers of vertices</li>
          <li>Insensitive to additional points on polygon edges</li>
          <li>Monotonic with linear response to small changes in translation, rotation, and scale</li>
          <li>A true metric in the mathematical sense (satisfies triangle inequality)</li>
        </ul>
        
        <strong>IoU (Intersection over Union)</strong> measures the overlap between two polygons as the ratio of their intersection area to their union area:
        $$\text{IoU}(A,B) = \frac{\text{Area}(A \cap B)}{\text{Area}(A \cup B)} = \frac{\text{Area}(A \cap B)}{\text{Area}(A) + \text{Area}(B) - \text{Area}(A \cap B)}$$
        IoU ranges from 0 (no overlap) to 1 (perfect overlap) and is widely used in object detection and segmentation tasks.
        <br><br>
        
        <strong>When they agree vs. differ:</strong> Both metrics detect large-scale misalignment and shape differences. However, 
        PoLiS is more sensitive to positional shifts and boundary irregularities even when overlap remains high, while IoU primarily 
        reflects area-based similarity and can remain stable despite shape deformations. Try rotating or translating the polygons 
        slightly—you'll notice PoLiS increases while IoU may stay relatively constant.
        <br><br>
        
        Here the <b style="color:var(--blue-stroke)">blue</b> rectangle is polygon A and the
        <b style="color:var(--violet-stroke)">purple</b> polygon is polygon B. Drag and reshape B, or rotate A, to explore
        how both metrics respond.
        <br><br>
        <small style="color:var(--muted)">
          Reference: Avbelj, J., Müller, R., & Bamler, R. (2014). A metric for polygon comparison and building extraction evaluation. 
          <em>IEEE Geoscience and Remote Sensing Letters, 12</em>(1), 170-174. 
          [<a href="https://elib.dlr.de/90425/1/avbelj_GRSL_00093_2014_final_submitted.pdf" target="_blank" style="color:#2563eb">PDF</a>]
        </small>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div class="body">
          <div class="stage-wrap">
            <svg id="stage" class="stage" width="900" height="540"></svg>
          </div>
          <div class="hint">
            Move inside the <b style="color:var(--violet-stroke)">purple</b> polygon to translate it; drag its vertices
            to reshape. Drag the small <b style="color:var(--blue-stroke)">blue</b> circle above the rectangle to rotate it.
            Toggle “Show nearest-distance rays” to visualize which boundary points are closest.
          </div>
        </div>
      </div>

      <div class="card">
        <div class="body">
          <div class="metrics">
            <div class="metric accent">
              <small>PoLiS distance (A,B)</small>
              <div id="polisVal" class="val">0.00 px</div>
            </div>
            <div class="metric accent">
              <small>IoU (Intersection over Union)</small>
              <div id="iouVal" class="val">0.00</div>
            </div>
            <div class="metric">
              <small>Avg distance A → B</small>
              <div id="abVal" class="val">0.00 px</div>
            </div>
            <div class="metric">
              <small>Avg distance B → A</small>
              <div id="baVal" class="val">0.00 px</div>
            </div>
          </div>
          <div class="ctrl">
            <div id="showRaysSwitch" class="switch on" role="switch" aria-checked="true">
              <div class="knob"></div>
            </div>
            <label for="showRaysSwitch">Show nearest-distance rays</label>
          </div>
          <div style="margin-top:16px;border-top:1px solid var(--border);padding-top:16px">
            <div style="text-align:center;font-size:13px;font-weight:600;margin-bottom:8px;color:var(--text)">IoU vs PoLiS</div>
            <canvas id="scatterPlot" width="268" height="200" style="border:1px solid var(--border);border-radius:8px;background:#fff"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Config ---
    const W = 900, H = 540;
    const HANDLE_R = 7;       // draggable vertex radius
    const ROT_HANDLE_R = 8;   // rotation handle radius

    // --- Utilities ---
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const dist2 = (a, b) => (a.x - b.x) ** 2 + (a.y - b.y) ** 2;

    function ns(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }

    // Distance helpers: closest point on a segment + distance
    function closestPointOnSegment(p, a, b){
      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const wx = p.x - a.x;
      const wy = p.y - a.y;
      const len2 = vx*vx + vy*vy;

      let t = 0;
      if (len2 > 0){
        t = (wx*vx + wy*vy) / len2;
      }
      t = Math.max(0, Math.min(1, t));

      const qx = a.x + t * vx;
      const qy = a.y + t * vy;
      const dx = p.x - qx;
      const dy = p.y - qy;
      return { point: { x: qx, y: qy }, dist: Math.hypot(dx, dy) };
    }

    // Per-vertex directed PoLiS distances: A → B
    function perVertexDirectedDistances(A, B){
      const res = [];
      if (!A.length || !B.length) return res;

      for (let i = 0; i < A.length; i++){
        const p = A[i];
        let best = null;

        for (let j = 0; j < B.length; j++){
          const a = B[j];
          const b = B[(j + 1) % B.length];
          const cand = closestPointOnSegment(p, a, b);
          if (!best || cand.dist < best.dist) best = cand;
        }
        if (best) res.push({ from: p, to: best.point, dist: best.dist });
      }
      return res;
    }

    function avgDistance(entries){
      if (!entries.length) return 0;
      return entries.reduce((s, e) => s + e.dist, 0) / entries.length;
    }

    function computePolis(A, B){
      // Directed A → B and B → A
      const AB = perVertexDirectedDistances(A, B);
      const BA = perVertexDirectedDistances(B, A);
      const dAB = avgDistance(AB);
      const dBA = avgDistance(BA);
      const polis = 0.5 * (dAB + dBA);
      return { AB, BA, dAB, dBA, polis };
    }

    function pointInPoly(pt, poly){
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++){
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect =
          (yi > pt.y) !== (yj > pt.y) &&
          pt.x < ((xj - xi) * (pt.y - yi)) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Compute polygon area using shoelace formula
    function polygonArea(poly){
      let area = 0;
      for (let i = 0; i < poly.length; i++){
        const j = (i + 1) % poly.length;
        area += poly[i].x * poly[j].y;
        area -= poly[j].x * poly[i].y;
      }
      return Math.abs(area / 2);
    }

    // Sutherland-Hodgman polygon clipping algorithm for intersection
    function clipPolygon(subject, clip){
      let output = [...subject];
      
      for (let i = 0; i < clip.length; i++){
        const input = output;
        output = [];
        if (input.length === 0) break;
        
        const edge1 = clip[i];
        const edge2 = clip[(i + 1) % clip.length];
        
        for (let j = 0; j < input.length; j++){
          const current = input[j];
          const prev = input[(j + input.length - 1) % input.length];
          
          const currentInside = isInside(current, edge1, edge2);
          const prevInside = isInside(prev, edge1, edge2);
          
          if (currentInside){
            if (!prevInside){
              const inter = lineIntersect(prev, current, edge1, edge2);
              if (inter) output.push(inter);
            }
            output.push(current);
          } else if (prevInside){
            const inter = lineIntersect(prev, current, edge1, edge2);
            if (inter) output.push(inter);
          }
        }
      }
      
      return output;
    }

    function isInside(p, e1, e2){
      return (e2.x - e1.x) * (p.y - e1.y) - (e2.y - e1.y) * (p.x - e1.x) >= 0;
    }

    function lineIntersect(p1, p2, p3, p4){
      const x1 = p1.x, y1 = p1.y;
      const x2 = p2.x, y2 = p2.y;
      const x3 = p3.x, y3 = p3.y;
      const x4 = p4.x, y4 = p4.y;
      
      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 1e-10) return null;
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      
      return {
        x: x1 + t * (x2 - x1),
        y: y1 + t * (y2 - y1)
      };
    }

    function computeIoU(A, B){
      const intersection = clipPolygon(A, B);
      if (intersection.length < 3) return 0;
      
      const areaA = polygonArea(A);
      const areaB = polygonArea(B);
      const areaIntersection = polygonArea(intersection);
      const areaUnion = areaA + areaB - areaIntersection;
      
      return areaUnion > 0 ? areaIntersection / areaUnion : 0;
    }

    // --- SVG setup ---
    const stage = document.getElementById('stage');
    const gridGroup = ns('g');
    const polyA = ns('polygon');
    const polyB = ns('polygon');
    const helperGroup = ns('g'); // rays & closest points
    const bHandles = ns('g');
    const aHandles = ns('g');

    polyA.setAttribute('fill','#3b82f60f');
    polyA.setAttribute('stroke','#2563eb');
    polyA.setAttribute('stroke-width','2');

    polyB.setAttribute('fill','#a855f70f');
    polyB.setAttribute('stroke','#7c3aed');
    polyB.setAttribute('stroke-width','2');

    stage.appendChild(gridGroup);
    stage.appendChild(polyA);
    stage.appendChild(polyB);
    stage.appendChild(helperGroup);
    stage.appendChild(bHandles);
    stage.appendChild(aHandles);

    // Grid
    (function drawGrid(){
      const step = 40;
      for(let x = step; x < W; x += step) addLine(x,0,x,H);
      for(let y = step; y < H; y += step) addLine(0,y,W,y);
      function addLine(x1,y1,x2,y2){
        const l = ns('line');
        l.setAttribute('x1',x1);
        l.setAttribute('y1',y1);
        l.setAttribute('x2',x2);
        l.setAttribute('y2',y2);
        l.setAttribute('stroke','#00000010');
        l.setAttribute('stroke-width','1');
        gridGroup.appendChild(l);
      }
    })();

    // --- Shapes ---
    function rectRot(cx,cy,w,h,ang){
      const c = Math.cos(ang), s = Math.sin(ang);
      const hw = w/2, hh = h/2;
      const pts = [[-hw,-hh],[hw,-hh],[hw,hh],[-hw,hh]];
      return pts.map(([dx,dy]) => ({
        x: cx + dx*c - dy*s,
        y: cy + dx*s + dy*c
      }));
    }

    let Acenter = { x: W*0.35, y: H*0.4 }, Awidth = 320, Aheight = 240, Aangle = 0;
    let A = rectRot(Acenter.x, Acenter.y, Awidth, Aheight, Aangle);

    function rotHandlePos(){
      // point above the rectangle center along -y in local frame
      const c = Math.cos(Aangle), s = Math.sin(Aangle);
      const dy = -(Aheight/2 + 28);
      const dx = 0;
      return {
        x: Acenter.x + dx*c - dy*s,
        y: Acenter.y + dx*s + dy*c
      };
    }

    const B0 = [
      {x:W*0.60,y:H*0.30},
      {x:W*0.80,y:H*0.30},
      {x:W*0.80,y:H*0.60},
      {x:W*0.60,y:H*0.60}
    ];
    let B = B0.map(p => ({...p}));

    // --- Interaction ---
    let drag = null; // {mode:'b-vertex'|'b-translate'|'a-rotate', index?, prev:{x,y}}

    function getPointer(evt){
      const r = stage.getBoundingClientRect();
      return {
        x: clamp(evt.clientX - r.left, 0, W),
        y: clamp(evt.clientY - r.top, 0, H)
      };
    }

    stage.addEventListener('pointerdown', (e)=>{
      const p = getPointer(e);
      const rh = rotHandlePos();

      // rotation handle first
      if (dist2(p, rh) <= (ROT_HANDLE_R+4)**2){
        drag = { mode:'a-rotate' };
        stage.setPointerCapture(e.pointerId);
        return;
      }

      // B vertex
      const thr2 = (HANDLE_R+3)**2;
      for (let i = 0; i < B.length; i++){
        if (dist2(p, B[i]) <= thr2){
          drag = { mode:'b-vertex', index:i };
          stage.setPointerCapture(e.pointerId);
          return;
        }
      }

      // B translate
      if (pointInPoly(p, B)){
        drag = { mode:'b-translate', prev:p };
        stage.setPointerCapture(e.pointerId);
      }
    });

    stage.addEventListener('pointermove', (e)=>{
      if (!drag) return;
      const p = getPointer(e);

      if (drag.mode === 'b-vertex'){
        const i = drag.index;
        B = B.map((q, idx) =>
          idx === i
            ? { x:clamp(p.x,0,W), y:clamp(p.y,0,H) }
            : q
        );
        updateScene();
      } else if (drag.mode === 'b-translate'){
        const dx = p.x - drag.prev.x;
        const dy = p.y - drag.prev.y;
        B = B.map(q => ({
          x: clamp(q.x + dx, 0, W),
          y: clamp(q.y + dy, 0, H)
        }));
        drag.prev = p;
        updateScene();
      } else if (drag.mode === 'a-rotate'){
        // angle from center to pointer, 0 means upright
        const ang = Math.atan2(p.y - Acenter.y, p.x - Acenter.x) - Math.PI / 2;
        Aangle = ang;
        A = rectRot(Acenter.x, Acenter.y, Awidth, Aheight, Aangle);
        updateScene();
      }
    });

    stage.addEventListener('pointerup', (e)=>{
      drag = null;
      try { stage.releasePointerCapture(e.pointerId); } catch {}
    });
    stage.addEventListener('pointerleave', ()=>{
      drag = null;
    });

    // Show/hide rays switch
    const showRaysSwitch = document.getElementById('showRaysSwitch');
    let showRays = true;
    showRaysSwitch.addEventListener('click', ()=>{
      showRays = !showRays;
      showRaysSwitch.classList.toggle('on', showRays);
      updateScene();
    });

    // --- Metrics elements ---
    const polisVal = document.getElementById('polisVal');
    const iouVal = document.getElementById('iouVal');
    const abVal = document.getElementById('abVal');
    const baVal = document.getElementById('baVal');

    // --- Scatter plot setup ---
    const canvas = document.getElementById('scatterPlot');
    const ctx = canvas.getContext('2d');
    const history = [];
    const MAX_HISTORY = 50;

    function drawScatterPlot(currentPolis, currentIoU){
      const w = canvas.width;
      const h = canvas.height;
      const padding = 40;
      const plotW = w - padding * 2;
      const plotH = h - padding * 2;

      // Clear canvas
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, w, h);

      // Draw axes
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, h - padding);
      ctx.lineTo(w - padding, h - padding);
      ctx.stroke();

      // Draw grid lines
      ctx.strokeStyle = '#f3f4f6';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= 5; i++){
        const y = padding + (plotH / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(w - padding, y);
        ctx.stroke();

        const x = padding + (plotW / 5) * i;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, h - padding);
        ctx.stroke();
      }

      // Labels
      ctx.fillStyle = '#6b7280';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      
      // X-axis label
      ctx.fillText('PoLiS (px)', w / 2, h - 5);
      
      // Y-axis label
      ctx.save();
      ctx.translate(10, h / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('IoU', 0, 0);
      ctx.restore();

      // Axis tick labels
      ctx.textAlign = 'right';
      ctx.fillText('1.0', padding - 5, padding + 5);
      ctx.fillText('0.5', padding - 5, padding + plotH / 2 + 5);
      ctx.fillText('0.0', padding - 5, h - padding + 5);

      ctx.textAlign = 'center';
      const maxPolis = 200; // reasonable max for display
      ctx.fillText('0', padding, h - padding + 15);
      ctx.fillText('100', padding + plotW / 2, h - padding + 15);
      ctx.fillText('200', w - padding, h - padding + 15);

      // Draw history trail
      for (let i = 0; i < history.length; i++){
        const pt = history[i];
        const age = history.length - i;
        const alpha = Math.max(0.1, 1 - (age / MAX_HISTORY));
        
        const x = padding + (pt.polis / maxPolis) * plotW;
        const y = h - padding - pt.iou * plotH;

        ctx.fillStyle = `rgba(99, 102, 241, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw current point
      const x = padding + (currentPolis / maxPolis) * plotW;
      const y = h - padding - currentIoU * plotH;

      ctx.fillStyle = '#4f46e5';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Add to history
      history.push({ polis: currentPolis, iou: currentIoU });
      if (history.length > MAX_HISTORY) history.shift();
    }

    // --- Render ---
    function updateScene(){
      // draw polygons
      polyA.setAttribute('points', A.map(p => `${p.x},${p.y}`).join(' '));
      polyB.setAttribute('points', B.map(p => `${p.x},${p.y}`).join(' '));

      // B handles (purple vertices)
      while (bHandles.firstChild) bHandles.removeChild(bHandles.firstChild);
      for (let i = 0; i < B.length; i++){
        const c = ns('circle');
        c.setAttribute('cx', B[i].x);
        c.setAttribute('cy', B[i].y);
        c.setAttribute('r', HANDLE_R);
        c.setAttribute('fill','#7c3aed');
        c.setAttribute('stroke','#fff');
        c.setAttribute('stroke-width','2');
        bHandles.appendChild(c);
      }

      // A rotation handle + rod
      while (aHandles.firstChild) aHandles.removeChild(aHandles.firstChild);
      const rh = rotHandlePos();
      const hc = ns('circle');
      hc.setAttribute('cx', rh.x);
      hc.setAttribute('cy', rh.y);
      hc.setAttribute('r', ROT_HANDLE_R);
      hc.setAttribute('fill','#2563eb');
      hc.setAttribute('stroke','#fff');
      hc.setAttribute('stroke-width','2');
      aHandles.appendChild(hc);

      const rod = ns('line');
      rod.setAttribute('x1', Acenter.x);
      rod.setAttribute('y1', Acenter.y);
      rod.setAttribute('x2', rh.x);
      rod.setAttribute('y2', rh.y);
      rod.setAttribute('stroke','#2563eb33');
      rod.setAttribute('stroke-width','2');
      aHandles.appendChild(rod);

      // Compute PoLiS + directed distances
      const { AB, BA, dAB, dBA, polis } = computePolis(A, B);
      const iou = computeIoU(A, B);

      // Rays & closest points visualization
      while (helperGroup.firstChild) helperGroup.removeChild(helperGroup.firstChild);
      if (showRays){
        // A → B rays (blue-ish)
        for (const entry of AB){
          const l = ns('line');
          l.setAttribute('x1', entry.from.x);
          l.setAttribute('y1', entry.from.y);
          l.setAttribute('x2', entry.to.x);
          l.setAttribute('y2', entry.to.y);
          l.setAttribute('stroke','#2563eb66');
          l.setAttribute('stroke-width','1.5');
          helperGroup.appendChild(l);

          const m = ns('circle');
          m.setAttribute('cx', entry.to.x);
          m.setAttribute('cy', entry.to.y);
          m.setAttribute('r', 3);
          m.setAttribute('fill','#2563eb');
          m.setAttribute('stroke','#ffffff');
          m.setAttribute('stroke-width','1');
          helperGroup.appendChild(m);
        }

        // B → A rays (purple-ish)
        for (const entry of BA){
          const l = ns('line');
          l.setAttribute('x1', entry.from.x);
          l.setAttribute('y1', entry.from.y);
          l.setAttribute('x2', entry.to.x);
          l.setAttribute('y2', entry.to.y);
          l.setAttribute('stroke','#a855f766');
          l.setAttribute('stroke-width','1.5');
          helperGroup.appendChild(l);

          const m = ns('circle');
          m.setAttribute('cx', entry.to.x);
          m.setAttribute('cy', entry.to.y);
          m.setAttribute('r', 3);
          m.setAttribute('fill','#a855f7');
          m.setAttribute('stroke','#ffffff');
          m.setAttribute('stroke-width','1');
          helperGroup.appendChild(m);
        }
      }

      // metrics (in pixel units)
      polisVal.textContent = polis.toFixed(2) + ' px';
      iouVal.textContent = iou.toFixed(3);
      abVal.textContent = dAB.toFixed(2) + ' px';
      baVal.textContent = dBA.toFixed(2) + ' px';

      // Update scatter plot
      drawScatterPlot(polis, iou);
    }

    updateScene();
  </script>
</body>
</html>
