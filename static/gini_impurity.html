<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Decision Tree Walkthrough (Gini Impurity)</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --accent:#2563eb;
      --accent2:#0ea5e9;
      --good:#16a34a;
      --warn:#f59e0b;
      --bad:#dc2626;
      --shadow: 0 10px 30px rgba(17,24,39,0.08);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background: var(--bg);
      color:var(--ink);
      font-family:var(--sans);
      line-height:1.35;
    }

    .wrap{
      max-width: 1400px;
      margin: 26px auto 56px;
      padding: 0 18px;
    }

    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      margin-bottom: 16px;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    h1{
      margin:0;
      font-size: 22px;
      letter-spacing:-0.02em;
    }

    .subtitle{
      color:var(--muted);
      font-size: 13px;
      max-width: 720px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.7);
      backdrop-filter: blur(8px);
      border-radius: 999px;
      box-shadow: 0 10px 20px rgba(17,24,39,0.06);
      font-size: 12px;
      color: var(--muted);
      user-select:none;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: linear-gradient(135deg,var(--accent),var(--accent2));
      box-shadow: 0 0 0 3px rgba(37,99,235,0.12);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: rgba(255,255,255,0.86);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.72));
    }
    .card .hd h2{
      margin:0;
      font-size: 14px;
      letter-spacing:-0.01em;
    }
    .card .bd{
      padding: 14px 16px 16px;
    }

    .nav{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-top: 12px;
      flex-wrap:wrap;
    }

    button{
      font-family:var(--sans);
      font-size: 0.9rem;
      border-radius: 8px;
      border:1px solid var(--border);
      background: var(--card);
      padding: 10px 16px;
      cursor:pointer;
      transition: all 0.2s;
      user-select:none;
    }
    button:hover{
      border-color: var(--accent);
      color: var(--accent);
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: var(--accent);
      color: white;
      border: none;
      font-weight: 500;
    }
    button.primary:hover{
      background: var(--accent2);
      color: white;
    }
    button:disabled{
      opacity: 0.45;
      cursor:not-allowed;
      transform:none !important;
      box-shadow:none !important;
    }

    .kpiRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }
    .kpi{
      flex: 1 1 160px;
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.75);
    }
    .kpi .k{
      color: var(--muted);
      font-size: 11px;
    }
    .kpi .v{
      font-family: var(--mono);
      font-size: 14px;
      margin-top: 4px;
    }

    .formula{
      border:1px dashed rgba(37,99,235,0.35);
      border-radius: 14px;
      background: rgba(37,99,235,0.06);
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: 12px;
      color: #0f172a;
    }
    .formula .small{
      color: var(--muted);
      font-family: var(--sans);
      font-size: 12px;
      margin-top: 6px;
    }

    table{
      width:100%;
      border-collapse: collapse;
      font-size: 13px;
      overflow:hidden;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.7);
    }
    th, td{
      padding: 8px 8px;
      border-bottom:1px solid var(--border);
      text-align:left;
    }
    th{
      font-size: 12px;
      color:#0f172a;
      background: rgba(17,24,39,0.03);
    }
    tr:last-child td{ border-bottom:none; }
    .mono{ font-family: var(--mono); }

    .rowInactive{
      opacity: 0.35;
      filter: grayscale(0.2);
    }
    .rowActive{
      background: rgba(14,165,233,0.08);
    }

    .badgeb{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 3px 8px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.8);
      font-size: 11px;
      color: var(--muted);
      white-space:nowrap;
    }
    .badgeb strong{
      color:#0f172a;
      font-weight:600;
    }
    .tagBest{
      border-color: rgba(22,163,74,0.35);
      background: rgba(22,163,74,0.08);
      color:#14532d;
    }
    .tagNote{
      border-color: rgba(245,158,11,0.35);
      background: rgba(245,158,11,0.10);
      color:#7c2d12;
    }

    .splitList{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top: 10px;
    }
    .splitItem{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.78);
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .splitItem input{ margin-top: 3px; }
    .splitItem .content{ flex:1; }
    .splitItem .head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .splitItem .name{
      font-weight:600;
      letter-spacing:-0.01em;
    }
    .splitItem .details{
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
    }
    .splitItem .grid2{
      margin-top: 8px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .mini{
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
      background: rgba(17,24,39,0.02);
      font-size: 12px;
    }
    .mini .tt{
      color:#0f172a;
      font-weight:600;
      font-size: 11px;
      margin-bottom: 4px;
    }
    .mini .kv{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-family: var(--mono);
      font-size: 12px;
      color:#0f172a;
    }

    .note{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    /* Tree SVG styling */
    .treeWrap{
      width:100%;
      overflow:hidden;
      border-radius: 14px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.7);
    }
    svg{ width:100%; height:auto; display:block; }
    .edge{
      stroke: rgba(17,24,39,0.35);
      stroke-width: 1.5;
    }
    .edgeLabel{
      font-family: var(--mono);
      font-size: 20px;
      fill: rgba(17,24,39,0.85);
    }
    .nodeRect{
      fill: rgba(255,255,255,0.95);
      stroke: rgba(17,24,39,0.16);
      stroke-width: 1.2;
      rx: 12;
    }
    .nodeRect.highlight{
      stroke: rgba(37,99,235,0.55);
      stroke-width: 2;
      filter: drop-shadow(0 10px 18px rgba(37,99,235,0.18));
    }
    .nodeTitle{
      font-family: var(--sans);
      font-weight: 650;
      font-size: 26px;
      fill: #0f172a;
    }
    .nodeText{
      font-family: var(--mono);
      font-size: 22px;
      fill: rgba(17,24,39,0.80);
    }
    .nodePred{
      font-family: var(--sans);
      font-size: 21px;
      fill: rgba(17,24,39,0.78);
    }
    .leafBadge{
      fill: rgba(22,163,74,0.10);
      stroke: rgba(22,163,74,0.30);
    }
    .leafBadgeText{
      font-family: var(--mono);
      font-size: 18px;
      fill: #14532d;
    }

    .stepTitle{
      font-size: 13px;
      font-weight: 650;
      margin: 0 0 8px 0;
      letter-spacing:-0.01em;
    }
    .stepBody{
      color:#0f172a;
      font-size: 13px;
    }
    .stepBody p{ margin: 0 0 10px 0; }
    .stepBody p:last-child{ margin-bottom: 0; }

    .muted{ color: var(--muted); }

    .footerTiny{
      margin-top: 10px;
      font-size: 11px;
      color: var(--muted);
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Decision Tree Walkthrough: Greedy Splits with Gini Impurity</h1>
        <div class="subtitle">
          Step through how a CART-style decision tree selects splits using <span class="mono">weighted Gini</span>, with full per-node counts, impurities, and gains.
          Override the split at each step to compare outcomes and see how the tree shape and leaf purity change.
        </div>
      </div>
    </header>

    <div class="grid">
      <!-- Left: Walkthrough + dataset -->
      <section class="card">
        <div class="hd">
          <h2>Walkthrough</h2>
          <div class="badgeb"><strong id="stepCounter">Step 1 / 8</strong><span id="stepName" class="mono"></span></div>
        </div>
        <div class="bd">
          <div id="stepContent"></div>

          <div class="nav">
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <button id="prevBtn">&lt;- Previous</button>
              <button id="nextBtn" class="primary">Next -&gt;</button>
              <button id="resetBtn" title="Reset choices & go back to the start">Reset</button>
            </div>
            <div class="badgeb" id="choiceBadge" style="display:none;"></div>
          </div>

          <div class="footerTiny">
            Tip: use <span class="mono">Previous</span> to go back and pick a different split.
          </div>
        </div>

        <div class="hd">
          <h2>Dataset</h2>
          <div class="badgeb"><strong id="focusBadge">All rows</strong></div>
        </div>
        <div class="bd">
          <div id="datasetTable"></div>
        </div>
      </section>

      <!-- Right: Tree + metrics -->
      <aside class="card">
        <div class="hd">
          <h2>Tree being built</h2>
          <div class="badgeb"><strong id="treeStatus">Not split yet</strong></div>
        </div>
        <div class="bd">
          <div class="treeWrap">
            <svg id="treeSvg" viewBox="0 0 1300 720" role="img" aria-label="Decision tree diagram"></svg>
          </div>

          <div style="height:12px"></div>

          <div class="kpiRow">
            <div class="kpi">
              <div class="k">Root counts</div>
              <div class="v" id="kpiCounts">a: 0, b: 0</div>
            </div>
            <div class="kpi">
              <div class="k">Root Gini</div>
              <div class="v" id="kpiRootGini">0.0000</div>
            </div>
            <div class="kpi">
              <div class="k">Best weighted Gini (current node)</div>
              <div class="v" id="kpiBestWG">--</div>
            </div>
          </div>

          <div style="height:12px"></div>

          <div class="formula" id="formulaBox">
            Gini(S) = 1 - Sum<sub>k</sub> p<sub>k</sub><sup>2</sup>  =  1 - (p<sub>a</sub><sup>2</sup> + p<sub>b</sub><sup>2</sup>)<br/>
            WeightedGini(S, split) = (|S<sub>0</sub>|/|S|)*Gini(S<sub>0</sub>) + (|S<sub>1</sub>|/|S|)*Gini(S<sub>1</sub>)
            <div class="small">Here S<sub>0</sub> is the subset where the chosen feature = 0, and S<sub>1</sub> is where the feature = 1.</div>
          </div>

        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  // --- Dataset ---
  // Default: random 10-row toy dataset (binary features, labels a/b)
  // Use the fixed example dataset when URL has an example flag
  const EXAMPLE_DATA = [
    {id: 1, y: "a", f1: 1, f2: 0},
    {id: 2, y: "a", f1: 0, f2: 1},
    {id: 3, y: "b", f1: 0, f2: 1},
    {id: 4, y: "b", f1: 0, f2: 1},
    {id: 5, y: "a", f1: 0, f2: 0},
    {id: 6, y: "b", f1: 0, f2: 1},
    {id: 7, y: "b", f1: 0, f2: 1},
    {id: 8, y: "a", f1: 1, f2: 0},
    {id: 9, y: "b", f1: 0, f2: 1},
    {id:10, y: "a", f1: 0, f2: 1},
  ];

  const randomLabel = () => (Math.random() < 0.5 ? "a" : "b");
  const randomBit = () => (Math.random() < 0.5 ? 0 : 1);
  const makeRandomData = (n=10) => {
    const rows = [];
    for (let i = 1; i <= n; i += 1) {
      rows.push({ id: i, y: randomLabel(), f1: randomBit(), f2: randomBit() });
    }
    return rows;
  };

  const urlHasExample = new URLSearchParams(window.location.search).has("example");
  const DATA = urlHasExample ? EXAMPLE_DATA : makeRandomData(10);
  const FEATURES = [
    {key: "f1", name: "Feature 1"},
    {key: "f2", name: "Feature 2"},
  ];
  const CLASSES = ["a","b"];

  // --- Utils ---
  const fmt = (x, digits=4) => {
    if (x === null || x === undefined || Number.isNaN(x)) return "--";
    return (Math.round(x * 10**digits) / 10**digits).toFixed(digits);
  };
  const countsOf = (indices) => {
    const c = {a:0, b:0};
    for (const i of indices) c[DATA[i].y] += 1;
    return c;
  };
  const gini = (indices) => {
    const n = indices.length;
    if (n === 0) return 0;
    const c = countsOf(indices);
    let sumSq = 0;
    for (const k of CLASSES) {
      const p = c[k]/n;
      sumSq += p*p;
    }
    return 1 - sumSq;
  };
  const uniqueVals = (indices, featureKey) => {
    const s = new Set(indices.map(i => DATA[i][featureKey]));
    return Array.from(s).sort();
  };
  const splitMetrics = (indices, featureKey) => {
    const left = indices.filter(i => DATA[i][featureKey] === 0);
    const right = indices.filter(i => DATA[i][featureKey] === 1);
    const n = indices.length;
    const gL = gini(left);
    const gR = gini(right);
    const w = (left.length/n)*gL + (right.length/n)*gR;
    const parent = gini(indices);
    return {
      featureKey,
      left, right,
      parentGini: parent,
      giniLeft: gL,
      giniRight: gR,
      weightedGini: w,
      gain: parent - w,
      countsParent: countsOf(indices),
      countsLeft: countsOf(left),
      countsRight: countsOf(right),
    };
  };

  const bestSplit = (indices, bannedFeatures=[]) => {
    const candidates = [];
    for (const f of FEATURES) {
      if (bannedFeatures.includes(f.key)) continue;
      const u = uniqueVals(indices, f.key);
      if (u.length < 2) continue; // can't split
      candidates.push(splitMetrics(indices, f.key));
    }
    candidates.sort((a,b) => a.weightedGini - b.weightedGini);
    return candidates.length ? {best: candidates[0], all: candidates} : {best: null, all: []};
  };

  // --- Tree representation ---
  // Node: { id, indices, gini, counts, splitFeatureKey|null, left|null, right|null, pathFeatures[] }
  let nodeCounter = 0;
  const makeNode = (indices, pathFeatures=[]) => {
    const c = countsOf(indices);
    const pred = (c.a >= c.b) ? "a" : "b";
    return {
      id: `n${++nodeCounter}`,
      indices: [...indices],
      pathFeatures: [...pathFeatures],
      counts: c,
      gini: gini(indices),
      pred,
      splitFeatureKey: null,
      left: null,
      right: null,
    };
  };

  const applySplit = (node, featureKey) => {
    node.splitFeatureKey = featureKey;
    const leftIdx = node.indices.filter(i => DATA[i][featureKey] === 0);
    const rightIdx = node.indices.filter(i => DATA[i][featureKey] === 1);
    node.left = makeNode(leftIdx, [...node.pathFeatures, featureKey]);
    node.right = makeNode(rightIdx, [...node.pathFeatures, featureKey]);
    return node;
  };

  const isLeaf = (node) => !node.left && !node.right;
  const findFirstSplittableLeaf = (node) => {
    const q = [node];
    while (q.length) {
      const cur = q.shift();
      if (isLeaf(cur)) {
        if (cur.gini <= 1e-12) continue;
        const {best} = bestSplit(cur.indices, cur.pathFeatures);
        if (best) return cur;
      } else {
        q.push(cur.left, cur.right);
      }
    }
    return null;
  };

  // --- Step state ---
  // Base steps that always exist
  const BASE_STEPS = [
    { key:"intro", title:"Setup" },
    { key:"root_gini", title:"Compute root impurity" },
  ];
  const ROOT_SPLIT_STEPS = [
    { key:"choose_root", title:"Score each root split" },
    { key:"apply_root", title:"Apply the chosen root split" },
  ];
  // These repeat for each leaf split
  const LEAF_SPLIT_STEPS = [
    { key:"choose_leaf", title:"Find the next node to split" },
    { key:"choose_leaf_split", title:"Score splits for that node" },
    { key:"apply_leaf_split", title:"Apply the chosen split" },
  ];
  const SUMMARY_STEP = { key:"summary", title:"Summary" };

  const state = {
    step: 0,
    selectedRootFeature: null, // will be set to best split
    // Map from node path (e.g. "L" or "R" or "LL") to selected feature key
    leafSplitChoices: {},
  };

  // Simulate building the tree with current choices to determine max splits
  // Returns both split info and the paths of each leaf that gets split
  const simulateTreeBuild = () => {
    const savedCounter = nodeCounter;
    nodeCounter = 0;

    const allIndices = DATA.map((_,i)=>i);
    const root = makeNode(allIndices, []);
    const rootSplits = bestSplit(root.indices, []);
    const hasRootSplit = !!rootSplits.best;

    const leafSplitPaths = []; // Track path of each leaf split in order

    if (hasRootSplit) {
      // Use selected root feature or best
      const rootFeature = state.selectedRootFeature || rootSplits.best.featureKey;
      applySplit(root, rootFeature);

      // Count how many leaf splits are possible (BFS order)
      const queue = [
        { node: root.left, path: "L" },
        { node: root.right, path: "R" }
      ];

      while (queue.length > 0) {
        const { node, path } = queue.shift();
        if (!node || node.gini <= 1e-12) continue;

        const splits = bestSplit(node.indices, node.pathFeatures);
        if (splits.best) {
          leafSplitPaths.push(path);
          // Simulate applying this split to see if children can split further
          const chosenFeature = state.leafSplitChoices[path] || splits.best.featureKey;
          applySplit(node, chosenFeature);
          queue.push(
            { node: node.left, path: path + "L" },
            { node: node.right, path: path + "R" }
          );
        }
      }
    }

    nodeCounter = savedCounter;
    return { hasRootSplit, leafSplitPaths };
  };

  const getSteps = () => {
    const { hasRootSplit, leafSplitPaths } = simulateTreeBuild();

    const steps = [...BASE_STEPS];
    if (hasRootSplit) {
      steps.push(...ROOT_SPLIT_STEPS);
      for (let i = 0; i < leafSplitPaths.length; i++) {
        const path = leafSplitPaths[i];
        // Clone with unique keys for each iteration, include the path
        steps.push(
          { key: `choose_leaf_${i}`, title: `Find the next node to split`, leafIndex: i, leafPath: path },
          { key: `choose_leaf_split_${i}`, title: `Score splits for that node`, leafIndex: i, leafPath: path },
          { key: `apply_leaf_split_${i}`, title: `Apply the chosen split`, leafIndex: i, leafPath: path },
        );
      }
    }
    steps.push(SUMMARY_STEP);
    return steps;
  };

  // --- DOM ---
  const stepCounterEl = document.getElementById("stepCounter");
  const stepNameEl = document.getElementById("stepName");
  const stepContentEl = document.getElementById("stepContent");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const resetBtn = document.getElementById("resetBtn");
  const datasetTableEl = document.getElementById("datasetTable");
  const focusBadgeEl = document.getElementById("focusBadge");
  const choiceBadgeEl = document.getElementById("choiceBadge");

  const treeSvg = document.getElementById("treeSvg");
  const treeStatusEl = document.getElementById("treeStatus");
  const kpiCountsEl = document.getElementById("kpiCounts");
  const kpiRootGiniEl = document.getElementById("kpiRootGini");
  const kpiBestWGEl = document.getElementById("kpiBestWG");

  // --- Build a tree that matches the current step ---
  const buildTreeForStep = () => {
    nodeCounter = 0;
    const root = makeNode(DATA.map((_,i)=>i), []);

    const steps = getSteps();
    const currentStepKey = steps[state.step]?.key || "";

    // Find indices for key steps
    const applyRootIdx = steps.findIndex(s => s.key === "apply_root");

    // root selection defaults to best at root
    const rootSplits = bestSplit(root.indices, []);
    if (rootSplits.best && !state.selectedRootFeature) {
      state.selectedRootFeature = rootSplits.best.featureKey;
    }

    // Apply root split if we're past that step
    if (applyRootIdx !== -1 && state.step >= applyRootIdx && state.selectedRootFeature) {
      applySplit(root, state.selectedRootFeature);

      // Determine how many leaf splits to apply based on current step
      // Find all apply_leaf_split steps before or at current step
      const leafSplitSteps = steps
        .map((s, i) => ({ ...s, idx: i }))
        .filter(s => s.key.startsWith("apply_leaf_split_") && s.idx <= state.step);

      // Apply leaf splits in order (BFS through the tree)
      const queue = [
        { node: root.left, path: "L" },
        { node: root.right, path: "R" }
      ];
      let appliedCount = 0;

      while (queue.length > 0 && appliedCount < leafSplitSteps.length) {
        const { node, path } = queue.shift();
        if (!node || node.gini <= 1e-12) continue;

        const splits = bestSplit(node.indices, node.pathFeatures);
        if (splits.best) {
          // This node can be split - apply it if we've reached that step
          const chosenFeature = state.leafSplitChoices[path] || splits.best.featureKey;
          applySplit(node, chosenFeature);
          appliedCount++;

          // Add children to queue for potential further splits
          queue.push(
            { node: node.left, path: path + "L" },
            { node: node.right, path: path + "R" }
          );
        }
      }
    }

    return root;
  };

  // --- Layout the tree for SVG (generic enough for depth <= 3) ---
  const computeLeafWidths = (node) => {
    if (isLeaf(node)) return 1;
    return computeLeafWidths(node.left) + computeLeafWidths(node.right);
  };

  const assignPositions = (node, x0, x1, depth, positions) => {
    const cx = (x0 + x1) / 2;
    positions.set(node.id, {x: cx, y: depth});
    if (!isLeaf(node)) {
      const wL = computeLeafWidths(node.left);
      const wR = computeLeafWidths(node.right);
      const w = wL + wR;
      const splitX = x0 + (x1 - x0) * (wL / w);
      assignPositions(node.left, x0, splitX, depth+1, positions);
      assignPositions(node.right, splitX, x1, depth+1, positions);
    }
  };

  const nodeTitle = (node) => {
    if (node.splitFeatureKey) {
      const f = FEATURES.find(x=>x.key===node.splitFeatureKey);
      return `Split on ${f ? f.name : node.splitFeatureKey}`;
    }
    return "Leaf";
  };

  const nodeSubtitle = (node) => {
    const n = node.indices.length;
    const c = node.counts;
    return `n=${n}  a:${c.a}  b:${c.b}`;
  };

  const featureName = (k) => FEATURES.find(f=>f.key===k)?.name ?? k;

  const renderTreeSvg = (root, highlightNodeId=null) => {
    // Determine depth
    const depth = (node) => isLeaf(node) ? 1 : 1 + Math.max(depth(node.left), depth(node.right));
    const D = depth(root);

    // SVG constants
    const W = 1300;
    const H = Math.max(620, 220 + (D-1)*240);
    treeSvg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    treeSvg.innerHTML = "";

    const positions = new Map();
    assignPositions(root, 170, W-170, 0, positions);

    const yMap = (d) => 140 + d*240;

    const drawEdge = (fromId, toId, label) => {
      const p0 = positions.get(fromId);
      const p1 = positions.get(toId);
      const x0 = p0.x, y0 = yMap(p0.y);
      const x1 = p1.x, y1 = yMap(p1.y);

      const line = document.createElementNS("http://www.w3.org/2000/svg","path");
      const midY = (y0 + y1)/2;
      line.setAttribute("d", `M ${x0} ${y0+70} C ${x0} ${midY} ${x1} ${midY} ${x1} ${y1-70}`);
      line.setAttribute("class","edge");
      treeSvg.appendChild(line);

      const tx = (x0 + x1)/2;
      const ty = (midY - 6);
      const text = document.createElementNS("http://www.w3.org/2000/svg","text");
      text.setAttribute("x", tx);
      text.setAttribute("y", ty);
      text.setAttribute("text-anchor","middle");
      text.setAttribute("class","edgeLabel");
      text.textContent = label;
      treeSvg.appendChild(text);
    };

    const drawNode = (node) => {
      const p = positions.get(node.id);
      const x = p.x, y = yMap(p.y);
      const w = 420, h = 165;
      const x0 = x - w/2, y0 = y - h/2;

      const g = document.createElementNS("http://www.w3.org/2000/svg","g");

      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x0);
      rect.setAttribute("y", y0);
      rect.setAttribute("width", w);
      rect.setAttribute("height", h);
      rect.setAttribute("class", `nodeRect ${node.id===highlightNodeId ? "highlight" : ""}`);
      g.appendChild(rect);

      const t1 = document.createElementNS("http://www.w3.org/2000/svg","text");
      t1.setAttribute("x", x0+22);
      t1.setAttribute("y", y0+40);
      t1.setAttribute("class","nodeTitle");
      t1.textContent = nodeTitle(node);
      g.appendChild(t1);

      const t2 = document.createElementNS("http://www.w3.org/2000/svg","text");
      t2.setAttribute("x", x0+22);
      t2.setAttribute("y", y0+76);
      t2.setAttribute("class","nodeText");
      t2.textContent = nodeSubtitle(node);
      g.appendChild(t2);

      const t3 = document.createElementNS("http://www.w3.org/2000/svg","text");
      t3.setAttribute("x", x0+22);
      t3.setAttribute("y", y0+112);
      t3.setAttribute("class","nodeText");
      t3.textContent = `gini=${fmt(node.gini)}`;
      g.appendChild(t3);

      const t4 = document.createElementNS("http://www.w3.org/2000/svg","text");
      t4.setAttribute("x", x0+22);
      t4.setAttribute("y", y0+148);
      t4.setAttribute("class","nodePred");
      t4.textContent = `predict: ${node.pred}`;
      g.appendChild(t4);

      // Leaf badge if pure
      if (isLeaf(node) && node.gini <= 1e-12) {
        const badge = document.createElementNS("http://www.w3.org/2000/svg","rect");
        badge.setAttribute("x", x0+w-110);
        badge.setAttribute("y", y0+18);
        badge.setAttribute("width", 90);
        badge.setAttribute("height", 30);
        badge.setAttribute("rx", 15);
        badge.setAttribute("class","leafBadge");
        g.appendChild(badge);

        const bt = document.createElementNS("http://www.w3.org/2000/svg","text");
        bt.setAttribute("x", x0+w-65);
        bt.setAttribute("y", y0+40);
        bt.setAttribute("text-anchor","middle");
        bt.setAttribute("class","leafBadgeText");
        bt.textContent = "PURE";
        g.appendChild(bt);
      }

      treeSvg.appendChild(g);
    };

    // Draw edges first
    const walkEdges = (node) => {
      if (!isLeaf(node)) {
        const f = featureName(node.splitFeatureKey);
        drawEdge(node.id, node.left.id, `${f}=0`);
        drawEdge(node.id, node.right.id, `${f}=1`);
        walkEdges(node.left);
        walkEdges(node.right);
      }
    };
    walkEdges(root);

    // Draw nodes
    const walkNodes = (node) => {
      drawNode(node);
      if (!isLeaf(node)) {
        walkNodes(node.left);
        walkNodes(node.right);
      }
    };
    walkNodes(root);
  };

  // --- Dataset table with row highlighting ---
  const renderDatasetTable = (activeIndexSet) => {
    const isActive = (i) => !activeIndexSet || activeIndexSet.has(i);
    const html = [];
    html.push('<table>');
    html.push('<thead><tr><th class="mono">id</th><th>Label</th><th>Feature 1</th><th>Feature 2</th></tr></thead>');
    html.push('<tbody>');
    for (let i=0;i<DATA.length;i++){
      const r = DATA[i];
      const cls = isActive(i) ? "rowActive" : "rowInactive";
      html.push(`<tr class="${cls}"><td class="mono">${r.id}</td><td class="mono">${r.y}</td><td class="mono">${r.f1}</td><td class="mono">${r.f2}</td></tr>`);
    }
    html.push('</tbody></table>');
    datasetTableEl.innerHTML = html.join("");
  };

  // --- Split option list UI ---
  const renderSplitOptions = (splits, selectedKey, onChange, bestKey, contextLabel) => {
    if (!splits.length) {
      return `<div class="note">
        <span class="badgeb tagNote"><strong>No valid split</strong></span>
        <div style="margin-top:8px">
          Every remaining feature is constant for this node, so the tree cannot create a non-trivial split.
        </div>
      </div>`;
    }

    const items = splits.map(m => {
      const fName = featureName(m.featureKey);
      const isBest = (m.featureKey === bestKey);
      const checked = (m.featureKey === selectedKey) ? "checked" : "";
      const bestBadge = isBest ? '<span class="badgeb tagBest"><strong>best</strong></span>' : '';
      const wLabel = `<span class="badgeb"><strong>weighted gini</strong>&nbsp;<span class="mono">${fmt(m.weightedGini)}</span></span>`;
      const gainLabel = `<span class="badgeb"><strong>gain</strong>&nbsp;<span class="mono">${fmt(m.gain)}</span></span>`;

      return `
        <label class="splitItem">
          <input type="radio" name="${contextLabel}" value="${m.featureKey}" ${checked}/>
          <div class="content">
            <div class="head">
              <div class="name">${fName}</div>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                ${bestBadge}
                ${wLabel}
                ${gainLabel}
              </div>
            </div>
            <div class="details">
              Split rule: <span class="mono">${fName}=0</span> vs <span class="mono">${fName}=1</span>.
              Parent gini: <span class="mono">${fmt(m.parentGini)}</span>.
            </div>
            <div class="grid2">
              <div class="mini">
                <div class="tt">${fName}=0 (S<sub>0</sub>)</div>
                <div class="kv"><span>n</span><span>${m.left.length}</span></div>
                <div class="kv"><span>a,b</span><span>${m.countsLeft.a}, ${m.countsLeft.b}</span></div>
                <div class="kv"><span>gini</span><span>${fmt(m.giniLeft)}</span></div>
              </div>
              <div class="mini">
                <div class="tt">${fName}=1 (S<sub>1</sub>)</div>
                <div class="kv"><span>n</span><span>${m.right.length}</span></div>
                <div class="kv"><span>a,b</span><span>${m.countsRight.a}, ${m.countsRight.b}</span></div>
                <div class="kv"><span>gini</span><span>${fmt(m.giniRight)}</span></div>
              </div>
            </div>
          </div>
        </label>
      `;
    });

    // Attach handler after injection
    setTimeout(() => {
      const radios = stepContentEl.querySelectorAll(`input[name="${contextLabel}"]`);
      radios.forEach(r => r.addEventListener("change", (e) => onChange(e.target.value)));
    }, 0);

    return `<div class="splitList">${items.join("")}</div>`;
  };

  // --- Step rendering ---
  const renderStep = () => {
    const steps = getSteps();
    const total = steps.length;
    if (state.step >= total) state.step = total - 1;
    if (state.step < 0) state.step = 0;
    stepCounterEl.textContent = `Step ${state.step+1} / ${total}`;
    stepNameEl.textContent = steps[state.step].title;

    // Build current tree
    const root = buildTreeForStep();

    // KPIs
    kpiCountsEl.textContent = `a: ${root.counts.a}, b: ${root.counts.b}`;
    kpiRootGiniEl.textContent = fmt(root.gini);
    treeStatusEl.textContent = root.splitFeatureKey ? "In progress" : "Not split yet";

    // Highlight and focus set
    let highlightNodeId = null;
    let focusSet = null;
    let focusLabel = "All rows";

    // Prepare step content
    let contentHTML = "";
    choiceBadgeEl.style.display = "none";
    choiceBadgeEl.innerHTML = "";

    if (steps[state.step].key === "intro") {
      highlightNodeId = root.id;
      focusSet = new Set(root.indices);
      focusLabel = "All rows (root node)";

      contentHTML = `
        <div class="stepTitle">What we are building</div>
        <div class="stepBody">
          <p>
            We will build a small classification tree to predict the label (<span class="mono">a</span> or <span class="mono">b</span>)
            from two binary features (<span class="mono">Feature 1</span> and <span class="mono">Feature 2</span>).
          </p>
          <p>
            At each node, we consider splits of the form <span class="mono">Feature j = 0</span> vs <span class="mono">Feature j = 1</span>,
            compute the <span class="mono">weighted Gini</span> for each split, and choose the lowest one (greedy).
          </p>
          <p>
            This dataset is generated at page load, so the best split and tree shape will vary from run to run.
          </p>
          <p class="muted">
            Use <span class="mono">Next</span> to compute the root impurity and then score each candidate split.
          </p>
        </div>
      `;
    }

    if (steps[state.step].key === "root_gini") {
      highlightNodeId = root.id;
      focusSet = new Set(root.indices);
      focusLabel = "All rows (root node)";

      const n = root.indices.length;
      const pa = root.counts.a / n;
      const pb = root.counts.b / n;
      const sumSq = pa*pa + pb*pb;

      contentHTML = `
        <div class="stepTitle">Root impurity (before any split)</div>
        <div class="stepBody">
          <p>
            The root contains all <span class="mono">${n}</span> samples.
            The class counts are <span class="mono">a:${root.counts.a}</span>, <span class="mono">b:${root.counts.b}</span>.
          </p>
          <div class="kpiRow" style="margin-top:10px;">
            <div class="kpi"><div class="k">Class probabilities</div><div class="v">p(a)=${fmt(pa)}, p(b)=${fmt(pb)}</div></div>
            <div class="kpi"><div class="k">Sum p^2</div><div class="v">${fmt(sumSq)}</div></div>
            <div class="kpi"><div class="k">Gini(root)</div><div class="v">${fmt(root.gini)}</div></div>
          </div>
          <p class="note">
            Lower Gini means the node is “more pure”. A pure node (all <span class="mono">a</span> or all <span class="mono">b</span>)
            has Gini = 0.
          </p>
        </div>
      `;
    }

    if (steps[state.step].key === "choose_root") {
      highlightNodeId = root.id;
      focusSet = new Set(root.indices);
      focusLabel = "All rows (scoring root split)";

      const {best, all} = bestSplit(root.indices, []);
      const bestKey = best ? best.featureKey : null;
      if (bestKey && !state.selectedRootFeature) state.selectedRootFeature = bestKey;

      kpiBestWGEl.textContent = best ? fmt(best.weightedGini) : "--";

      contentHTML = `
        <div class="stepTitle">Score each possible split at the root</div>
        <div class="stepBody">
          <p>
            For each feature, we split the data into <span class="mono">S<sub>0</sub></span> (feature=0) and <span class="mono">S<sub>1</sub></span> (feature=1),
            compute each child’s Gini, then take a size-weighted average.
          </p>
          <p class="muted">
            The greedy algorithm chooses the split with the <strong>lowest</strong> weighted Gini.
            You can pick a different split to see what happens.
          </p>
        </div>
        ${renderSplitOptions(all, state.selectedRootFeature, (k)=>{ state.selectedRootFeature=k; renderStep(); }, bestKey, "rootSplit")}
        <div class="note">
          Current selection: <span class="mono">${featureName(state.selectedRootFeature)}</span>.
          ${bestKey && state.selectedRootFeature !== bestKey ? `<span class="badgeb tagNote" style="margin-left:8px;"><strong>not the best</strong></span>` : bestKey ? `<span class="badgeb tagBest" style="margin-left:8px;"><strong>best</strong></span>` : ``}
        </div>
      `;

      choiceBadgeEl.style.display = "inline-flex";
      choiceBadgeEl.innerHTML = `<strong>Selected root split</strong>&nbsp;<span class="mono">${featureName(state.selectedRootFeature)}</span>`;
    }

    if (steps[state.step].key === "apply_root") {
      // Root split is applied in buildTreeForStep
      highlightNodeId = root.id;
      focusLabel = `Root split applied: ${featureName(root.splitFeatureKey)}`;
      focusSet = new Set(root.indices);

      // Compute metrics for the chosen root split (for display)
      const m = splitMetrics(root.indices, root.splitFeatureKey);
      kpiBestWGEl.textContent = fmt(m.weightedGini);

      contentHTML = `
        <div class="stepTitle">Apply the root split</div>
        <div class="stepBody">
          <p>
            We split on <span class="mono">${featureName(root.splitFeatureKey)}</span>.
            The weighted Gini is <span class="mono">${fmt(m.weightedGini)}</span>, so the impurity reduction (“gain”) is
            <span class="mono">${fmt(m.gain)}</span>.
          </p>
          <div class="kpiRow" style="margin-top:10px;">
            <div class="kpi"><div class="k">Left child (${featureName(root.splitFeatureKey)}=0)</div><div class="v">n=${m.left.length}, a:${m.countsLeft.a}, b:${m.countsLeft.b}, gini=${fmt(m.giniLeft)}</div></div>
            <div class="kpi"><div class="k">Right child (${featureName(root.splitFeatureKey)}=1)</div><div class="v">n=${m.right.length}, a:${m.countsRight.a}, b:${m.countsRight.b}, gini=${fmt(m.giniRight)}</div></div>
          </div>
          <p class="muted" style="margin-top:10px;">
            Next, we look for the next leaf that is impure and still has a feature we can split on.
          </p>
        </div>
      `;

      choiceBadgeEl.style.display = "inline-flex";
      choiceBadgeEl.innerHTML = `<strong>Root split</strong>&nbsp;<span class="mono">${featureName(root.splitFeatureKey)}</span>`;
    }

    // Handle dynamic leaf split steps (choose_leaf_N, choose_leaf_split_N, apply_leaf_split_N)
    const currentStepKey = steps[state.step].key;
    const leafIndexMatch = currentStepKey.match(/^(choose_leaf|choose_leaf_split|apply_leaf_split)_(\d+)$/);

    if (leafIndexMatch) {
      const stepType = leafIndexMatch[1];
      const leafIndex = parseInt(leafIndexMatch[2], 10);
      // Get the path from the step object (computed during getSteps)
      const leafPath = steps[state.step].leafPath;

      // Helper to find a node by its path
      const findNodeByPath = (node, path) => {
        if (!path || path.length === 0) return node;
        const dir = path[0];
        const rest = path.slice(1);
        if (dir === "L" && node.left) return findNodeByPath(node.left, rest);
        if (dir === "R" && node.right) return findNodeByPath(node.right, rest);
        return null;
      };

      // For choose_leaf and choose_leaf_split, the split hasn't been applied yet
      // For apply_leaf_split, the split HAS been applied, so the node is no longer a leaf
      const targetNode = findNodeByPath(root, leafPath);

      if (stepType === "choose_leaf") {
        if (!targetNode) {
          highlightNodeId = null;
          focusSet = new Set(root.indices);
          focusLabel = "No more splittable leaves";
          kpiBestWGEl.textContent = "--";
          contentHTML = `
            <div class="stepTitle">No more work to do</div>
            <div class="stepBody">
              <p>All remaining leaves are either pure (Gini = 0) or cannot be split further.</p>
            </div>
          `;
        } else {
          highlightNodeId = targetNode.id;
          focusSet = new Set(targetNode.indices);
          focusLabel = `Focus: leaf #${leafIndex + 1} to split`;
          kpiBestWGEl.textContent = "--";

          contentHTML = `
            <div class="stepTitle">Choose which leaf to split next (leaf #${leafIndex + 1})</div>
            <div class="stepBody">
              <p>
                A standard greedy tree keeps splitting while there is an impure leaf that has a valid split.
                The next splittable leaf has <span class="mono">n=${targetNode.indices.length}</span> samples with counts
                <span class="mono">a:${targetNode.counts.a}</span>, <span class="mono">b:${targetNode.counts.b}</span>, so
                Gini <span class="mono">${fmt(targetNode.gini)}</span>.
              </p>
              <p class="muted">Next we will score splits at this leaf.</p>
            </div>
          `;
        }
      }

      if (stepType === "choose_leaf_split") {
        if (!targetNode) {
          highlightNodeId = null;
          focusSet = new Set(root.indices);
          focusLabel = "No splittable leaf";
          contentHTML = `
            <div class="stepTitle">No valid split remains</div>
            <div class="stepBody">
              <p>
                There is no leaf with both (1) non-zero impurity and (2) a feature that can split it.
                The tree will stop growing.
              </p>
              <p class="muted">Press Next to see the final summary.</p>
            </div>
          `;
        } else {
          const banned = targetNode.pathFeatures;
          const { best, all } = bestSplit(targetNode.indices, banned);

          highlightNodeId = targetNode.id;
          focusSet = new Set(targetNode.indices);
          focusLabel = "Rows in the current leaf";

          const bestKey = best ? best.featureKey : null;

          // Initialize selection for this leaf if not set
          if (bestKey && !state.leafSplitChoices[leafPath]) {
            state.leafSplitChoices[leafPath] = bestKey;
          }
          const selectedKey = state.leafSplitChoices[leafPath] || bestKey;

          kpiBestWGEl.textContent = best ? fmt(best.weightedGini) : "--";

          const radioName = `leafSplit_${leafPath}`;
          contentHTML = `
            <div class="stepTitle">Score splits for the highlighted leaf (leaf #${leafIndex + 1})</div>
            <div class="stepBody">
              <p>
                We only consider features that are not already used on the path to this leaf.
                We again choose the split with the lowest weighted Gini.
              </p>
            </div>
            <div class="note">
              Features used on path: <span class="mono">${banned.map(featureName).join(", ") || "none"}</span>.
              Remaining: <span class="mono">${FEATURES.map(f=>f.key).filter(k=>!banned.includes(k)).map(featureName).join(", ") || "none"}</span>.
            </div>
            ${renderSplitOptions(all, selectedKey, (k)=>{ state.leafSplitChoices[leafPath]=k; renderStep(); }, bestKey, radioName)}
            <div class="note">
              Current selection: <span class="mono">${featureName(selectedKey)}</span>.
              ${bestKey && selectedKey !== bestKey ? `<span class="badgeb tagNote" style="margin-left:8px;"><strong>not the best</strong></span>` : bestKey ? `<span class="badgeb tagBest" style="margin-left:8px;"><strong>best</strong></span>` : ``}
            </div>
          `;

          choiceBadgeEl.style.display = "inline-flex";
          choiceBadgeEl.innerHTML = `<strong>Selected split for leaf #${leafIndex + 1}</strong>&nbsp;<span class="mono">${featureName(selectedKey)}</span>`;
        }
      }

      if (stepType === "apply_leaf_split") {
        // The split has already been applied by buildTreeForStep
        // targetNode should now be an internal node (not a leaf)
        const splitNode = targetNode;

        if (splitNode && splitNode.splitFeatureKey) {
          highlightNodeId = splitNode.id;
          focusSet = new Set(splitNode.indices);
          focusLabel = `Split #${leafIndex + 2} applied`; // +2 because root is split #1

          const m = splitMetrics(splitNode.indices, splitNode.splitFeatureKey);
          kpiBestWGEl.textContent = fmt(m.weightedGini);

          // Check if there are more splits coming
          const nextLeafStepIdx = steps.findIndex((s, i) => i > state.step && s.key.startsWith("choose_leaf_"));
          const moreToGo = nextLeafStepIdx !== -1;

          contentHTML = `
            <div class="stepTitle">Apply the split (leaf #${leafIndex + 1})</div>
            <div class="stepBody">
              <p>
                We split the highlighted leaf on <span class="mono">${featureName(splitNode.splitFeatureKey)}</span>.
                The weighted Gini for this split is <span class="mono">${fmt(m.weightedGini)}</span>
                (gain <span class="mono">${fmt(m.gain)}</span> relative to that node).
              </p>
              <p class="muted">${moreToGo ? "Next we will check for more leaves to split." : "Next we will summarize what the final tree learned."}</p>
            </div>
          `;
        } else {
          highlightNodeId = null;
          focusSet = new Set(root.indices);
          focusLabel = "Split could not be applied";
          kpiBestWGEl.textContent = "--";

          contentHTML = `
            <div class="stepTitle">Stop condition: no valid split remains</div>
            <div class="stepBody">
              <p>
                There is no remaining feature that can split an impure leaf into two non-empty groups.
                The greedy algorithm stops and returns the current tree.
              </p>
              <p class="muted">Press Next to see the final summary.</p>
            </div>
          `;
        }
      }
    }

    if (steps[state.step].key === "summary") {
      const root2 = buildTreeForStep();
      const rootSplit = root2.splitFeatureKey ? featureName(root2.splitFeatureKey) : "none";
      let depth = 1;
      const depthRec = (n) => isLeaf(n) ? 1 : 1 + Math.max(depthRec(n.left), depthRec(n.right));
      depth = depthRec(root2);

      // Count leaves and pure leaves
      let leaves = 0, pureLeaves = 0;
      const walk = (n) => {
        if (isLeaf(n)) {
          leaves += 1;
          if (n.gini <= 1e-12) pureLeaves += 1;
        } else { walk(n.left); walk(n.right); }
      };
      walk(root2);

      contentHTML = `
        <div class="stepTitle">What this tree learned</div>
        <div class="stepBody">
          <p>
            Final root split: <span class="mono">${rootSplit}</span>.
            Tree depth: <span class="mono">${depth}</span>. Leaves: <span class="mono">${leaves}</span> (pure: <span class="mono">${pureLeaves}</span>).
          </p>
          <p>
            On this run, the best root split (lowest weighted Gini) was <span class="mono">${rootSplit}</span>.
            Try a different root split to see how the tree shape and purity change.
          </p>
          <p class="muted">
            Go back and choose a different root split to see how the tree shape (and purity) changes.
          </p>
        </div>
      `;

      highlightNodeId = root2.id;
      focusSet = new Set(root2.indices);
      focusLabel = "All rows (done)";
      kpiBestWGEl.textContent = "--";
    }

    // Default best WG on steps where it isn't set
    if (!kpiBestWGEl.textContent || kpiBestWGEl.textContent === "--") {
      const rootSplits = bestSplit(root.indices, []);
      kpiBestWGEl.textContent = rootSplits.best ? fmt(rootSplits.best.weightedGini) : "--";
    }

    // Render content
    stepContentEl.innerHTML = contentHTML;

    // Update focus & dataset
    focusBadgeEl.textContent = focusLabel;
    renderDatasetTable(focusSet);

    // Render tree
    renderTreeSvg(root, highlightNodeId);

    // Update navigation buttons
    prevBtn.disabled = (state.step === 0);
    nextBtn.disabled = (state.step === total - 1);

    // Tree status label
    const stepKey = steps[state.step].key;
    treeStatusEl.textContent = (() => {
      if (stepKey === "intro" || stepKey === "root_gini" || stepKey === "choose_root") return "Not split yet";
      if (stepKey === "apply_root" || stepKey === "choose_leaf" || stepKey === "choose_leaf_split") return "After root split";
      return "Final / stopping";
    })();
  };

  // --- Navigation handlers ---
  prevBtn.addEventListener("click", () => {
    if (state.step > 0) state.step -= 1;
    renderStep();
  });
  nextBtn.addEventListener("click", () => {
    const total = getSteps().length;
    if (state.step < total - 1) state.step += 1;
    renderStep();
  });
  resetBtn.addEventListener("click", () => {
    state.step = 0;
    state.selectedRootFeature = null;
    state.leafSplitChoices = {};
    renderStep();
  });

  // Initial render
  renderStep();
})();
</script>

<footer style="text-align:center; padding:24px 16px; color:#6b7280; font-size:13px;">
By: Caleb Robinson, 2026
</footer>

</body>
</html>

